## 基础

Git仓库： 记录文件状态内容的地方，存储着修改的历史记录

Git的三个区域： 

- 工作区： 当前文件夹
- 暂存区： 保存之前的准备区域（暂时提交，或者是临时保存，与版本库解耦）
- 版本库： 提交并保存暂存区中的内容，产生一个版本快照（实际提价）
- 远程仓库： 远程的仓库

文件提交流程： 在当前文件夹进行编辑，时不时`git add .`一下，开发好一个版本后，执行`git commit`指令，如果需要将内容传到远程仓库，执行`git push -u origin master`指令（可以多次`git add` 一次`git commit`）

## 初始化Git

`git -v` 查看Git版本信息

`git init` 在当前文件夹中初始化一个新的Git仓库

## 提交操作

`git add . ` 暂存全部改动的文件，将当前文件夹的内容提交到__暂存区__中

`git add 文件名` 暂存指定文件

`git commit -m "注释"` 提交并保存，产生版本快照，将当前文件夹的内容提交到版本库 

## 远程操作

`git remote -v` 查看连接的仓库信息

`git remote add origin URL` 配置连接远程仓库的URL

`git remote rm origin` 移除远程仓库

`git push origin master` 将版本库中的文件传到远程仓库上

## 分支

每一条分支都会拥有自己的版本库信息，并且__互不干扰__，一般用于多人开发不影响主分支，或处理Bug时使用

`git branch` 查看全部的分支

- `git branch 分支名` 创建新分支，新分支会拥有当前主分支的版本库信息
- `git branch -d 分支名` 删除分支

`git checkout 分支名` 切换分支

- `git checkout -b 分支名` 创建并切换分支

`git merge 分支名` 合并分支，会在主分支的基础上，添加上其他分支的提交记录，并且主分支会自动跳到最新的记录上

- 当主分支产生了新的提交记录时，其他分支再进行合并操作时（在合并分支时，原来主分支的提交记录和现在主分支的提交记录不同），其他分支的提交记录会保存到主分支中（提交记录按照提交时间排序），并且Git主分支会产生一个新的提交记录（自动创建）

### 合并冲突

合并分支的时候对同一文件进行了不同的修改，此时`git merge`合并分支时，会产生合并冲突错误

解决： 修改某一分支的内容，再次提交

## 暂存区操作

`git restore 文件名` 将暂存区内容覆盖到工作区中（`.`覆盖全部文件）

`git rm --cached 文件名` 将暂存区中的指定内容删除（`.`删除整个暂存区的缓存，此时文件会变成未跟踪文件）

- 删除一个文件的缓存，重新覆盖不会导致该文件删除（该文件已经进入未跟踪状态）

## 版本库操作

`git log --oneline` 查看当前的版本记录（简略信息）

`git reflog --oneline` 查看完整的版本记录

`git reset` 将版本库的某个版本恢复到工作区/暂存区中

- `git reset --soft 版本号` 工作区/暂存区中都尽可能保存原文件夹中的文件内容
- `git reset --hard 版本号` 工作区/暂存区中，原文件夹下只剩下版本库中的内容，其他多余文件（__受到Git管理的文件__，不受Git管理的文件不受到影响）都会被清空
- `git reset --mixed` 暂存区中使用hard，工作区中使用soft（默认）

## 文件状态

`git ls-files` 查看对那些文件进行了管理（暂存区中存在哪些文件）

`git status -s` 查看当前暂存下文件状态（简略信息），第一列是暂存区状态，第二列是工作区状态

文件拥有四种状态：

- 未跟踪（U || ?）：暂存区中没有的文件，例如新文件或删除缓存的文件，从未被Git管理过，由于没有`git add`过，git并不知道对文件进行了什么操作
- 已跟踪（A）：Git已经知道和管理的文件
- 未修改（''）：未修改文件内容，三个区域的内容完全一致
- 已修改（M）：工作区中修改了文件内容

## 忽略文件

`.gitignore`文件可以让git彻底忽略跟踪指定文件

新建`.gitignore`文件，在文件中编写需要忽略的文件类型（不需要指定文件目录）

```
node_modules
*.log
a.txt
```







